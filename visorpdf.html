<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Presentaci√≥n PDF con Transici√≥n de Cristal</title>
  <!-- PDF.js desde archivos locales para mejor rendimiento -->
  <script src="./pdf.min.js"></script>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%; background: #f0f4f8; display: flex;
      justify-content: center; align-items: center; overflow: hidden; position: relative;
    }
    
    /* Indicador de carga inicial */
    #loading-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 30;
      background: rgba(255, 255, 255, 0.9);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #6C7A89;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #loading-text {
      font-family: sans-serif;
      color: #333;
      font-size: 16px;
      margin-bottom: 10px;
    }
    
    #loading-progress {
      width: 200px;
      height: 8px;
      background-color: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 0 auto;
    }
    
    #loading-bar {
      height: 100%;
      width: 0%;
      background-color: #28a745;
      transition: width 0.3s ease-in-out;
    }
    
    canvas {
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); border-radius: 8px;
      visibility: hidden; /* Oculta el canvas hasta que est√© listo */
    }
    
    #glass-overlay {
      position: absolute; inset: 0; background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(8px) saturate(150%); -webkit-backdrop-filter: blur(8px) saturate(150%);
      opacity: 0; pointer-events: none;
      transition: opacity 0.7s ease-in-out;
      z-index: 15;
    }
    
    #glass-overlay.active {
      opacity: 1;
    }
    
    .nav-button {
      position: absolute; top: 50%; transform: translateY(-50%); background-color: #6C7A89;
      border: none; padding: 15px; font-size: 24px; color: #ffffff; cursor: pointer;
      z-index: 20; border-radius: 10px; width: 50px; height: 50px; display: flex;
      justify-content: center; align-items: center; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: background-color 0.3s, box-shadow 0.3s;
    }
    
    .nav-button:hover { background-color: #5A6673; box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
    .nav-button:disabled { opacity: 0.4; cursor: not-allowed; }
    #prev-button { left: 10px; }
    #next-button { right: 10px; }
    
    #main-controls-container {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      width: 50%; max-width: 500px; display: flex; align-items: center; justify-content: space-between;
      gap: 8px; padding: 8px 12px; background-color: rgba(255, 255, 255, 0.8);
      border-radius: 25px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 20;
    }
    
    #left-controls, #center-controls, #right-controls { display: flex; align-items: center; gap: 8px; }
    #center-controls { flex-grow: 1; }
    #progress-container { flex-grow: 1; height: 12px; background-color: #e9ecef; border-radius: 6px; overflow: hidden; }
    #progress-bar { height: 100%; width: 0%; background-color: #28a745; transition: width 0.3s ease-in-out; }
    #timer { display: flex; align-items: center; padding: 8px 15px; background-color: #fff; border-radius: 20px; border: 1px solid #28a745; box-shadow: 0 2px 5px rgba(0,0,0,0.05); font-family: sans-serif; font-size: 16px; color: #343a40; }
    #timer .icon { margin-right: 8px; }
    .control-button { background-color: #6C7A89; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; transition: background-color 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); color: #fff; display: flex; justify-content: center; align-items: center; }
    .control-button:hover { background-color: #5A6673; }
    .control-button.active { background-color: #28a745; color: #fff; }
    
    #trophy-icon {
      width: 45px;
      height: 45px;
      display: none; /* Se oculta por defecto y se muestra en updateButtons */
      animation: medal-bounce 0.8s infinite alternate;
      font-size: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    @keyframes medal-bounce { from { transform: translateY(0); } to { transform: translateY(-8px); } }

    /* Estilos para la explosi√≥n de trofeos */
    #trophy-explosion-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 1px;
      height: 1px;
      overflow: visible;
      pointer-events: none;
      z-index: 25;
    }

    .explosion-trophy {
      position: absolute;
      font-size: 40px;
      opacity: 0;
      /* Animaci√≥n m√°s larga para el efecto de flotaci√≥n */
      animation: trophyExplode 3.5s ease-out forwards;
      white-space: nowrap;
      filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.7));
    }

    /* Keyframes modificados para el efecto de flotaci√≥n */
    @keyframes trophyExplode {
      0% {
        opacity: 0;
        transform: translate(0, 0) scale(0.5);
        filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.7));
      }
      10% {
        opacity: 1;
        transform: translate(var(--dx, 0px), var(--dy, 0px)) scale(1);
      }
      50% { /* Punto intermedio para el efecto flotante */
        opacity: 1;
        transform: translate(calc(var(--dx, 0px) * 1.5), calc(var(--dy, 0px) * 1.5)) scale(1.1); /* Se expande un poco m√°s */
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.9)); /* Brillo m√°s intenso */
      }
      100% {
        opacity: 0;
        transform: translate(calc(var(--dx, 0px) * 2), calc(var(--dy, 0px) * 2)) scale(0.8); /* Se mueven m√°s lejos y se encogen */
        filter: drop-shadow(0 0 2px rgba(255, 215, 0, 0.3)); /* Brillo tenue */
      }
    }
    /* Fin de estilos para la explosi√≥n de trofeos */

    #error-message { color: red; font-family: sans-serif; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
  </style>
</head>
<body>
     <!-- Indicador de carga inicial (solo se muestra si la carga es lenta) -->
   <div id="loading-container" style="display: none;">
     <div class="spinner"></div>
     <div id="loading-text">Cargando presentaci√≥n...</div>
     <div id="loading-progress">
       <div id="loading-bar"></div>
     </div>
   </div>
  
  <button id="prev-button" class="nav-button">&lt;</button>
  <button id="next-button" class="nav-button">&gt;</button>
  <canvas id="pdf-canvas"></canvas>
  <div id="glass-overlay"></div>
  <div id="trophy-explosion-container"></div>
  <div id="main-controls-container">
         <div id="left-controls"><button class="control-button" id="reset-zoom-btn" title="Restablecer Zoom"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg></button><button class="control-button" id="zoom-in-btn" title="Acercar">+</button><button class="control-button" id="zoom-out-btn" title="Alejar">-</button><button class="control-button" id="hand-btn" title="Mover">‚úã</button></div>
    <div id="center-controls"><div id="progress-container"><div id="progress-bar"></div></div></div>
    <div id="right-controls">
      <div id="trophy-icon">üèÜ</div>
      <div id="timer"><span class="icon">‚è∞</span><span id="timer-text">00:00</span></div>
    </div>
  </div>
  <div id="error-message"></div>

  <!-- Audio localizado para evitar descargas externas -->
  <audio id="victory-sound" preload="none"></audio>
  
  <script>
    const params = new URLSearchParams(window.location.search);
    const pdfUrl = params.get('pdf');

    if (!pdfUrl) {
             document.getElementById("error-message").textContent = "Error: No se encontr√≥ la direcci√≥n de la presentaci√≥n en la URL. Por favor, agregue ?pdf=URL_DE_LA_PRESENTACION";
      document.getElementById("loading-container").style.display = "none";
    } else {
      let pdfDoc = null, pageNum = 1, scale = 0.95, isHandMode = false, isDragging = false;
      let lastMouseX = 0, lastMouseY = 0, transformX = 0, transformY = 0;
      let isRendering = false;
      let isFirstRender = true; // Variable para controlar la primera carga
      let pageCache = new Map(); // Cache para p√°ginas precargadas

      const canvas = document.getElementById("pdf-canvas"), ctx = canvas.getContext("2d");
      const prevButton = document.getElementById("prev-button"), nextButton = document.getElementById("next-button");
      const progressBar = document.getElementById("progress-bar"), timerText = document.getElementById("timer-text");
      const trophyIcon = document.getElementById("trophy-icon"), resetZoomBtn = document.getElementById("reset-zoom-btn");
                    const zoomInBtn = document.getElementById("zoom-in-btn"), zoomOutBtn = document.getElementById("zoom-out-btn");
        const handBtn = document.getElementById("hand-btn");
        const glassOverlay = document.getElementById("glass-overlay");
      const trophyExplosionContainer = document.getElementById("trophy-explosion-container");
      const victorySound = document.getElementById("victory-sound");
      const loadingContainer = document.getElementById("loading-container");
      const loadingText = document.getElementById("loading-text");
      const loadingBar = document.getElementById("loading-bar");
      
      let startTime = Date.now();
      
      // Configuraci√≥n optimizada del worker
      pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
      const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

      // Funci√≥n para actualizar el indicador de carga
      function updateLoadingProgress(progress, text) {
        loadingBar.style.width = `${progress}%`;
        if (text) loadingText.textContent = text;
      }

                     // Funci√≥n para precargar TODAS las diapositivas con calidad progresiva (m√°s agresiva)
        async function preloadPagesInBatches() {
          const batchSize = 5; // Aumentado a 5 p√°ginas a la vez para mayor velocidad
          const totalPages = pdfDoc.numPages;
          
                     // Precargar TODAS las p√°ginas, excluyendo la primera que ya est√° cargada
           for (let startPage = 2; startPage <= totalPages; startPage += batchSize) {
             const endPage = Math.min(startPage + batchSize - 1, totalPages);
             const pagesInBatch = [];
             
             for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
               if (!pageCache.has(pageNum)) {
                 pagesInBatch.push(pageNum);
               }
             }
             
             if (pagesInBatch.length > 0) {
              
              // Precargar en paralelo para m√°xima velocidad
              const preloadPromises = pagesInBatch.map(async (pageNum) => {
                try {
                  const page = await pdfDoc.getPage(pageNum);
                  
                  // PRIMERA PASADA: Calidad baja (30%) para preview ultra r√°pido
                  const lowQualityViewport = page.getViewport({ scale: scale * 0.3 });
                  const lowQualityCanvas = document.createElement('canvas');
                  const lowQualityCtx = lowQualityCanvas.getContext('2d');
                  lowQualityCanvas.width = lowQualityViewport.width;
                  lowQualityCanvas.height = lowQualityViewport.height;
                  
                  await page.render({
                    canvasContext: lowQualityCtx,
                    viewport: lowQualityViewport
                  }).promise;
                  
                                        // Guardar preview de baja calidad
                      pageCache.set(pageNum, { 
                        page, 
                        viewport: lowQualityViewport,
                        lowQualityCanvas: lowQualityCanvas,
                        isLowQuality: true
                      });
                      
                      // SEGUNDA PASADA: Calidad √≥ptima en segundo plano (inmediato)
                      setTimeout(async () => {
                        try {
                          const optimalViewport = page.getViewport({ scale: scale });
                          const optimalCanvas = document.createElement('canvas');
                          const optimalCtx = optimalCanvas.getContext('2d');
                          optimalCanvas.width = optimalViewport.width;
                          optimalCanvas.height = optimalViewport.height;
                          
                          await page.render({
                            canvasContext: optimalCtx,
                            viewport: optimalViewport
                          }).promise;
                          
                          // Actualizar cache con calidad √≥ptima
                          pageCache.set(pageNum, { 
                            page, 
                            viewport: optimalViewport,
                            canvas: optimalCanvas,
                            isLowQuality: false
                          });
                        } catch (error) {
                          console.warn(`Error en calidad √≥ptima para p√°gina ${pageNum}:`, error);
                        }
                      }, 25);
                  
                } catch (error) {
                  console.warn(`Error precargando p√°gina ${pageNum}:`, error);
                }
              });
              
              // Esperar a que se complete el lote actual antes de continuar
              await Promise.all(preloadPromises);
              
              // Pausa m√≠nima entre lotes para no saturar el sistema
              await sleep(25);
            }
          }
          
          
        }
       
               // Funci√≥n para precargar p√°ginas adyacentes con calidad progresiva
        async function preloadAdjacentPages(currentPage) {
          const pagesToPreload = [];
          if (currentPage > 1) pagesToPreload.push(currentPage - 1);
          if (currentPage < pdfDoc.numPages) pagesToPreload.push(currentPage + 1);
          
          // Evitar precargar si no hay p√°ginas para precargar
          if (pagesToPreload.length === 0) return;
          
          for (const pageNum of pagesToPreload) {
            if (!pageCache.has(pageNum)) {
              try {
                // Usar calidad progresiva para p√°ginas adyacentes
                await renderPageWithProgressiveQuality(pageNum, true);
                
                // Mejorar a calidad √≥ptima en segundo plano
                setTimeout(async () => {
                  try {
                    await renderPageWithProgressiveQuality(pageNum, false);
                  } catch (error) {
                    console.warn(`Error mejorando calidad para p√°gina adyacente ${pageNum}:`, error);
                  }
                }, 25);
                
                               } catch (error) {
                 console.warn(`Error precargando diapositiva ${pageNum}:`, error);
               }
            }
          }
        }

               // Funci√≥n para limpiar cache de diapositivas lejanas (mucho menos agresiva)
         function cleanupPageCache(currentPage) {
           // Solo limpiar si hay demasiadas p√°ginas en cache (m√°s de 20)
           if (pageCache.size > 20) {
             const keysToDelete = [];
             for (const [pageNum] of pageCache) {
               // Mantener p√°ginas cercanas y solo eliminar las muy lejanas
               if (Math.abs(pageNum - currentPage) > 10) {
                 keysToDelete.push(pageNum);
               }
             }
             
             // Solo eliminar algunas p√°ginas para no ser muy agresivo
             const pagesToRemove = Math.min(keysToDelete.length, 5);
             for (let i = 0; i < pagesToRemove; i++) {
               pageCache.delete(keysToDelete[i]);
             }
             
                         }
          }
         
                             // FUNCI√ìN CORREGIDA: Renderizado con calidad progresiva para TODAS las p√°ginas
           async function renderPageWithProgressiveQuality(pageNum, isLowQuality = true) {
             try {
               let page, viewport;
               
               // Obtener la p√°gina del PDF
               if (pageCache.has(pageNum)) {
                 const cached = pageCache.get(pageNum);
                 page = cached.page;
                 viewport = cached.viewport;
               } else {
                 page = await pdfDoc.getPage(pageNum);
                 viewport = page.getViewport({ scale: scale });
                 pageCache.set(pageNum, { page, viewport });
               }
               
               if (isLowQuality) {
                 // PRIMERA PASADA: Calidad baja (30%) para preview inmediato
                 const lowQualityViewport = page.getViewport({ scale: scale * 0.3 });
                 
                 // Crear canvas temporal para no interferir con el principal
                 const tempCanvas = document.createElement('canvas');
                 const tempCtx = tempCanvas.getContext('2d');
                 tempCanvas.width = lowQualityViewport.width;
                 tempCanvas.height = lowQualityViewport.height;
                 
                 const renderContext = { canvasContext: tempCtx, viewport: lowQualityViewport };
                 await page.render(renderContext).promise;
                 
                 // Guardar en cache como baja calidad
                 pageCache.set(pageNum, { 
                   page, 
                   viewport: lowQualityViewport,
                   isLowQuality: true,
                   lowQualityCanvas: tempCanvas
                 });
                 
                                 } else {
                  // SEGUNDA PASADA: Calidad √≥ptima (100%)
                  const optimalViewport = page.getViewport({ scale: scale });
                  
                  // Crear canvas temporal para no interferir con el principal
                  const tempCanvas = document.createElement('canvas');
                  const tempCtx = tempCanvas.getContext('2d');
                  tempCanvas.width = optimalViewport.width;
                  tempCanvas.height = optimalViewport.height;
                  
                  const renderContext = { canvasContext: tempCtx, viewport: optimalViewport };
                  await page.render(renderContext).promise;
                  
                  // Actualizar cache con calidad √≥ptima
                  pageCache.set(pageNum, { 
                    page, 
                    viewport: optimalViewport,
                    isLowQuality: false,
                    canvas: tempCanvas
                  });
                }
               
             } catch (error) {
               console.error("Fall√≥ al renderizar la diapositiva con calidad progresiva:", error);
             }
           }

                      // Carga de la presentaci√≥n con indicadores de progreso
       let loadingStartTime = Date.now();
       let loadingTimeout = null;
       
       // Funci√≥n para mostrar el indicador de carga solo si tarda m√°s de 2 segundos
       function showLoadingIfSlow() {
         loadingTimeout = setTimeout(() => {
           loadingContainer.style.display = "block";
           updateLoadingProgress(50, "Presentaci√≥n cargada, preparando primera diapositiva...");
         }, 2000); // Solo mostrar despu√©s de 2 segundos
       }
       
       // Funci√≥n para ocultar el indicador de carga
       function hideLoading() {
         if (loadingTimeout) {
           clearTimeout(loadingTimeout);
           loadingTimeout = null;
         }
         loadingContainer.style.display = "none";
       }
       
       // Iniciar el temporizador para mostrar carga lenta
       showLoadingIfSlow();
       
       pdfjsLib.getDocument(pdfUrl).promise.then(pdf => {
         pdfDoc = pdf;
         
                 // Cargar la primera diapositiva con calidad progresiva (baja ‚Üí √≥ptima)
        setTimeout(async () => {
          try {
            // Si ya se mostr√≥ el indicador de carga, actualizar progreso
            if (loadingContainer.style.display !== "none") {
              updateLoadingProgress(80, "Renderizando primera diapositiva...");
            }
            
                         // PRIMERA PASADA: Cargar y mostrar la primera p√°gina inmediatamente
             const page = await pdfDoc.getPage(1);
             const viewport = page.getViewport({ scale: scale });
             
                           // Configurar y mostrar el canvas principal
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              canvas.style.visibility = 'visible';
              canvas.style.setProperty('visibility', 'visible', 'important');
              isFirstRender = false;
              
              // Renderizar la primera p√°gina en el canvas principal
              const renderContext = { canvasContext: ctx, viewport: viewport };
              await page.render(renderContext).promise;
             
             // Guardar en cache
             pageCache.set(1, { 
               page, 
               viewport: viewport,
               isLowQuality: false
             });
             
             // Ocultar indicador de carga inmediatamente
             hideLoading();
             
             // Iniciar timer
             setInterval(updateTimer, 1000);
             
                                        // Actualizar estado
              pageNum = 1;
              updateButtons();
              updateProgressBar();
              
              // Mostrar confirmaci√≥n visual
              loadingText.textContent = "¬°Primera p√°gina cargada!";
              loadingText.style.color = "#28a745";
              
              // Ocultar el indicador despu√©s de 1 segundo
              setTimeout(() => {
                loadingContainer.style.display = "none";
              }, 1000);
              
              // Iniciar precarga progresiva de todas las dem√°s p√°ginas en segundo plano
              setTimeout(() => {
                preloadPagesInBatches().then(() => {
                  // Precarga completada
                }).catch(error => {
                  console.warn("Error en precarga progresiva:", error);
                });
              }, 300);
            
          } catch (error) {
            console.error("Error en la carga inicial:", error);
            hideLoading();
            loadingText.textContent = "Error al cargar la primera diapositiva";
            loadingContainer.style.display = "block";
          }
        }, 30); // Reducido a 30ms para m√°xima velocidad
         
       }).catch(error => {
         document.getElementById("error-message").textContent = "Error al cargar la presentaci√≥n: " + error.message;
         hideLoading();
       });
      
                           async function renderPage(num) {
          isRendering = true;
          try {
            // Verificar si la diapositiva est√° en cache
            let page, viewport, cachedCanvas;
            if (pageCache.has(num)) {
              const cached = pageCache.get(num);
              page = cached.page;
              viewport = cached.viewport;
              cachedCanvas = cached.canvas || cached.lowQualityCanvas;
              
              // Si tenemos un canvas precargado, usarlo directamente
              if (cachedCanvas) {
                canvas.height = cachedCanvas.height;
                canvas.width = cachedCanvas.width;
                ctx.drawImage(cachedCanvas, 0, 0);
                
                // Si es de baja calidad, actualizar a calidad √≥ptima en segundo plano
                if (cached.isLowQuality) {
                  setTimeout(async () => {
                    try {
                      const optimalViewport = page.getViewport({ scale: scale });
                      const optimalCanvas = document.createElement('canvas');
                      const optimalCtx = optimalCanvas.getContext('2d');
                      optimalCanvas.width = optimalViewport.width;
                      optimalCanvas.height = optimalViewport.height;
                      
                      await page.render({
                        canvasContext: optimalCtx,
                        viewport: optimalViewport
                      }).promise;
                      
                      // Actualizar cache con calidad √≥ptima
                      pageCache.set(num, { 
                        page, 
                        viewport: optimalViewport,
                        canvas: optimalCanvas,
                        isLowQuality: false
                      });
                      
                      // Actualizar el canvas principal con calidad √≥ptima
                      canvas.height = optimalViewport.height;
                      canvas.width = optimalViewport.width;
                      ctx.drawImage(optimalCanvas, 0, 0);
                    } catch (error) {
                      console.warn(`Error actualizando calidad √≥ptima para p√°gina ${num}:`, error);
                    }
                  }, 50);
                }
              } else {
                // Renderizar normalmente si no hay canvas precargado
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                const renderContext = { canvasContext: ctx, viewport: viewport };
                await page.render(renderContext).promise;
              }
            } else {
              // P√°gina no est√° en cache, cargarla inmediatamente
              page = await pdfDoc.getPage(num);
              viewport = page.getViewport({ scale: scale });
              
              // Renderizar directamente en el canvas principal
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              const renderContext = { canvasContext: ctx, viewport: viewport };
              await page.render(renderContext).promise;
              
              // Guardar en cache para futuras navegaciones
              pageCache.set(num, { 
                page, 
                viewport: viewport,
                isLowQuality: false
              });
            }

            if (isFirstRender) {
              canvas.style.visibility = 'visible';
              isFirstRender = false;
            }

            canvas.style.transform = `translate(${transformX}px, ${transformY}px)`;
            
            // Limpiar cache de p√°ginas lejanas
            cleanupPageCache(num);
            
          } catch (error) {
            console.error("Fall√≥ al renderizar la diapositiva:", error);
          } finally {
            glassOverlay.classList.remove("active");
            isRendering = false;
          }
          
          // NO sobrescribir pageNum aqu√≠ - solo actualizar la interfaz
          updateButtons();
          updateProgressBar();
        }

      function triggerRender(action) {
        if (isRendering) return;
        glassOverlay.classList.add("active");
        requestAnimationFrame(() => {
          action();
        });
      }

                           function zoomIn() { 
          const newScale = Math.min(scale + 0.2, 3.0);
          triggerRender(() => { 
            scale = newScale; 
            renderPage(pageNum); 
          }); 
        }
        
        function zoomOut() { 
          const newScale = Math.max(scale - 0.2, 0.4);
          triggerRender(() => { 
            scale = newScale; 
            renderPage(pageNum); 
          }); 
        }
        
        function resetZoom() { 
          triggerRender(() => { 
            scale = 0.95; 
            transformX = 0; 
            transformY = 0; 
            renderPage(pageNum); 
          }); 
        }
      
             async function prevPage() {
         if (pageNum <= 1 || isRendering) return;
         glassOverlay.classList.add("active");
         await sleep(300);
         pageNum = pageNum - 1;
         renderPage(pageNum);
       }

       async function nextPage() {
         if (pageNum >= pdfDoc.numPages || isRendering) return;
         glassOverlay.classList.add("active");
         await sleep(300);
         pageNum = pageNum + 1;
         renderPage(pageNum);
       }

      function toggleHand() { isHandMode = !isHandMode; canvas.style.cursor = 'grab'; handBtn.classList.toggle('active', isHandMode); }
      canvas.addEventListener('mousedown', (e) => { if (isHandMode) { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; canvas.style.cursor = 'grabbing'; } });
      canvas.addEventListener('mousemove', (e) => { if (isDragging) { const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY; transformX += dx; transformY += dy; canvas.style.transform = `translate(${transformX}px, ${transformY}px)`; lastMouseX = e.clientX; lastMouseY = e.clientY; } });
      const stopDragging = () => { isDragging = false; if (isHandMode) canvas.style.cursor = 'grab'; };
      canvas.addEventListener('mouseup', stopDragging);
      canvas.addEventListener('mouseleave', stopDragging);
      
      function updateButtons() {
        if (!pdfDoc) return;
        prevButton.disabled = (pageNum <= 1);
        nextButton.disabled = (pageNum >= pdfDoc.numPages);

        if (pageNum === pdfDoc.numPages) {
          trophyIcon.style.display = 'flex';
          // Se llama a la funci√≥n de explosi√≥n solo una vez
          // para evitar m√∫ltiples activaciones si se hace clic r√°pido.
          // Un simple chequeo podr√≠a ser si ya hay trofeos.
          if (trophyExplosionContainer.children.length === 0) {
            triggerTrophyExplosion();
          }
        } else {
          trophyIcon.style.display = 'none';
        }
      }

             function updateProgressBar() { if (!pdfDoc) return; const progress = (pageNum / pdfDoc.numPages) * 100; progressBar.style.width = `${progress}%`; }
       function updateTimer() { const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0'); const seconds = String(elapsedTime % 60).padStart(2, '0'); timerText.textContent = `${minutes}:${seconds}`; }
       
       
      
      // --- INICIO DE C√ìDIGO MODIFICADO PARA R√ÅFAGAS Y FLUIDEZ ---
      
      // Funci√≥n para crear UNA r√°faga de trofeos
      function createBurst(numTrophies = 15, spreadRadius = 150) {
        for (let i = 0; i < numTrophies; i++) {
          const trophy = document.createElement('div');
          trophy.textContent = 'üèÜ';
          trophy.classList.add('explosion-trophy');

          // Calcular una posici√≥n aleatoria para cada copa
          const angle = Math.random() * 2 * Math.PI;
          const dx = Math.cos(angle) * (Math.random() * spreadRadius + 50); // Distancia X
          const dy = Math.sin(angle) * (Math.random() * spreadRadius + 50); // Distancia Y

          trophy.style.setProperty('--dx', `${dx}px`);
          trophy.style.setProperty('--dy', `${dy}px`);

          // Retraso aleatorio para un efecto m√°s natural
          const delay = Math.random() * 0.5;
          trophy.style.animationDelay = `${delay}s`;

          trophyExplosionContainer.appendChild(trophy);
        }
      }

      // Nueva funci√≥n para la explosi√≥n de trofeos en r√°fagas
      async function triggerTrophyExplosion() {
        // 1. Reproducir el sonido de victoria una sola vez al inicio
        // Nota: El audio ahora es local, no externo
        try {
          victorySound.currentTime = 0;
          await victorySound.play();
        } catch (e) {
          console.log("Audio no disponible:", e);
        }
        
        // Limpiar cualquier explosi√≥n anterior para empezar de cero
        trophyExplosionContainer.innerHTML = ''; 

        // 2. Par√°metros ajustados para mayor fluidez
        const numBursts = 4; // Aumentamos a 4 r√°fagas
        const delayBetweenBursts = 300; // Reducimos el delay
        
        // 3. Crear las r√°fagas en secuencia
        for (let i = 0; i < numBursts; i++) {
          createBurst(15, 200); // M√°s trofeos (15) y un radio de dispersi√≥n mayor (200px)
          await sleep(delayBetweenBursts); // Esperamos antes de la siguiente r√°faga
        }

        // 4. Limpiar las copas despu√©s de que termine TODA la animaci√≥n
        // Ajustado para la nueva duraci√≥n de animaci√≥n (3.5s) y el aumento de r√°fagas
        const totalAnimationTime = (numBursts * delayBetweenBursts) + 3500 + 500;
        setTimeout(() => {
          trophyExplosionContainer.innerHTML = ''; 
        }, totalAnimationTime);
      }
      
      // --- FIN DE C√ìDIGO MODIFICADO ---

                           prevButton.addEventListener("click", prevPage);
        nextButton.addEventListener("click", nextPage);
        zoomInBtn.addEventListener("click", zoomIn);
        zoomOutBtn.addEventListener("click", zoomOut);
        handBtn.addEventListener("click", toggleHand);
        resetZoomBtn.addEventListener("click", resetZoom);
    }
  </script>
</body>
</html>