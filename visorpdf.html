<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Visor PDF Definitivo: Estable y Profesional - Carga Ultra-R√°pida con Baja Resoluci√≥n Inicial</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
  <style>
    /* --- ESTILOS BASE Y DE RESET --- */
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%; background: #f0f4f8;
      display: flex; justify-content: center; align-items: center; overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      position: relative;
    }

    /* --- CONTENEDOR PRINCIPAL Y CANVAS (NUEVA UX DE CARGA) --- */
         #canvas-container {
       position: relative;
       background-color: transparent; /* Sin fondo para evitar cuadro blanco */
       box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
       border-radius: 8px;
       transition: width 0.2s ease-out, height 0.2s ease-out, transform 0.2s ease-out, opacity 0.5s ease-out;
       display: none; /* Oculto hasta que se cargue el PDF */
       opacity: 0;
       transform: scale(0.9);
     }
    #pdf-canvas {
      position: absolute; top: 0; left: 0;
      opacity: 1; /* Visible por defecto */
      border-radius: 8px;
      display: block; /* Asegurar que sea visible */
      min-width: 100px; /* Tama√±o m√≠nimo para evitar problemas de renderizado */
      min-height: 100px;
    }
    #loader {
      position: absolute; top: 50%; left: 50%;
      display: none; z-index: 10;
      border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
      border-radius: 50%; width: 40px; height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }

    /* --- CONTROLES DE NAVEGACI√ìN Y UI --- */
    #glass-overlay { position: absolute; inset: 0; background: rgba(255, 255, 255, 0.25); backdrop-filter: blur(8px) saturate(150%); -webkit-backdrop-filter: blur(8px) saturate(150%); opacity: 0; pointer-events: none; transition: opacity 0.5s ease-in-out; z-index: 15; border-radius: 8px; }
    #glass-overlay.active { opacity: 1; }
    .nav-button { position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(44, 62, 80, 0.6); border: none; padding: 15px; font-size: 24px; color: #ffffff; cursor: pointer; z-index: 20; border-radius: 10px; width: 50px; height: 50px; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: all 0.3s; backdrop-filter: blur(5px); }
    .nav-button:hover { background-color: rgba(44, 62, 80, 0.9); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
    .nav-button:disabled { opacity: 0.3; cursor: not-allowed; background-color: rgba(44, 62, 80, 0.2); }
    #prev-button { left: 15px; }
    #next-button { right: 15px; }
    
    /* --- BARRA DE CONTROLES INFERIOR (CORREGIDA Y COMPLETA) --- */
    #main-controls-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: auto; max-width: 90%; display: flex; align-items: center; justify-content: center; gap: 12px; padding: 8px 15px; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 25px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 20; }
    #left-controls, #center-controls, #right-controls { display: flex; align-items: center; gap: 8px; }
    #center-controls { flex-grow: 1; min-width: 150px; } 
         #progress-container { flex-grow: 1; height: 12px; background-color: #e9ecef; border-radius: 6px; overflow: hidden; position: relative; }
     #progress-bar { height: 100%; width: 0%; background-color: #27ae60; transition: width 0.5s ease-in-out; }
     #buffer-bar { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background-color: #bdc3c7; transition: width 0.5s ease-in-out; }
     #pages-progress-bar { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background-color: rgba(52, 152, 219, 0.6); transition: width 0.5s ease-in-out; border-radius: 6px; }
    #timer { display: flex; align-items: center; padding: 8px 15px; background-color: #fff; border-radius: 20px; border: 1px solid #27ae60; box-shadow: 0 2px 5px rgba(0,0,0,0.05); font-size: 16px; color: #34495e; }
    .control-button { background-color: #7f8c8d; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 18px; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); color: #fff; display: flex; justify-content: center; align-items: center; }
    .control-button:hover { background-color: #34495e; transform: translateY(-2px); }
    .control-button.active { background-color: #27ae60; }
    
    /* --- ESTILOS RESTAURADOS --- */
    #trophy-icon { 
      width: 45px; 
      height: 45px; 
      display: none; 
      animation: medal-bounce 0.8s infinite alternate; 
      font-size: 32px; 
      justify-content: center; 
      align-items: center; 
    }
    @keyframes medal-bounce { from { transform: translateY(0); } to { transform: translateY(-8px); } }
    #trophy-explosion-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1px; height: 1px; overflow: visible; pointer-events: none; z-index: 25; }
    .explosion-trophy { position: absolute; font-size: 40px; opacity: 0; animation: trophyExplode 3.5s ease-out forwards; white-space: nowrap; filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.7)); }
    @keyframes trophyExplode {
      0% { opacity: 0; transform: translate(0, 0) scale(0.5); } 10% { opacity: 1; transform: translate(var(--dx, 0px), var(--dy, 0px)) scale(1); }
      50% { opacity: 1; transform: translate(calc(var(--dx, 0px) * 1.5), calc(var(--dy, 0px) * 1.5)) scale(1.1); }
      100% { opacity: 0; transform: translate(calc(var(--dx, 0px) * 2), calc(var(--dy, 0px) * 2)) scale(0.8); }
    }
         #error-message { 
       color: #c0392b; 
       font-family: sans-serif; 
       position: absolute; 
       top: 50%; 
       left: 50%; 
       transform: translate(-50%, -50%); 
       background: #fff; 
       padding: 20px; 
       border-radius: 8px; 
       box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
       z-index: 40;
       display: none; /* Oculto por defecto */
     }

     /* --- ANIMACIONES DE CARGA IMPACTANTES --- */
     .loading-container {
       text-align: center;
       background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
       backdrop-filter: blur(20px);
       -webkit-backdrop-filter: blur(20px);
       padding: 40px;
       border-radius: 20px;
       box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2);
       border: 1px solid rgba(255, 255, 255, 0.3);
       animation: loadingPulse 2s ease-in-out infinite;
     }

     @keyframes loadingPulse {
       0%, 100% { transform: scale(1); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2); }
       50% { transform: scale(1.05); box-shadow: 0 25px 80px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.4); }
     }

     .loading-animation {
       display: flex;
       justify-content: center;
       align-items: center;
       gap: 12px;
       margin-bottom: 25px;
     }

     .loading-circle {
       width: 20px;
       height: 20px;
       border-radius: 50%;
       background: linear-gradient(45deg, #3498db, #2980b9);
       animation: loadingBounce 1.4s ease-in-out infinite both;
       box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
     }

     .loading-circle:nth-child(1) { animation-delay: -0.32s; }
     .loading-circle:nth-child(2) { animation-delay: -0.16s; }
     .loading-circle:nth-child(3) { animation-delay: 0s; }

     @keyframes loadingBounce {
       0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
       40% { transform: scale(1.2); opacity: 1; }
     }

     .loading-text {
       color: #2c3e50;
     }

     .loading-title {
       font-size: 48px;
       margin-bottom: 15px;
       animation: titleFloat 3s ease-in-out infinite;
       filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
     }

     @keyframes titleFloat {
       0%, 100% { transform: translateY(0px) rotate(0deg); }
       25% { transform: translateY(-8px) rotate(2deg); }
       75% { transform: translateY(-4px) rotate(-1deg); }
     }

     .loading-subtitle {
       font-size: 24px;
       font-weight: 600;
       margin-bottom: 20px;
       background: linear-gradient(45deg, #34495e, #2c3e50);
       -webkit-background-clip: text;
       -webkit-text-fill-color: transparent;
       background-clip: text;
       animation: subtitleGlow 2s ease-in-out infinite alternate;
     }

     @keyframes subtitleGlow {
       0% { filter: drop-shadow(0 0 5px rgba(52, 73, 94, 0.3)); }
       100% { filter: drop-shadow(0 0 15px rgba(52, 73, 94, 0.6)); }
     }

     .loading-dots {
       display: flex;
       justify-content: center;
       gap: 8px;
     }

     .loading-dots span {
       width: 8px;
       height: 8px;
       border-radius: 50%;
       background: linear-gradient(45deg, #e74c3c, #c0392b);
       animation: dotsPulse 1.5s ease-in-out infinite;
     }

     .loading-dots span:nth-child(1) { animation-delay: 0s; }
     .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
     .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

     @keyframes dotsPulse {
       0%, 100% { transform: scale(0.8); opacity: 0.4; }
       50% { transform: scale(1.3); opacity: 1; }
     }
  </style>
</head>
<body>
  <button id="prev-button" class="nav-button">&lt;</button>
  <button id="next-button" class="nav-button">&gt;</button>
  <div id="canvas-container">
    <canvas id="pdf-canvas"></canvas>
    <div id="loader"></div>
  </div>
  <div id="glass-overlay"></div>
  <div id="trophy-explosion-container"></div>
  <div id="main-controls-container">
    <div id="left-controls">
      <button class="control-button" id="reset-zoom-btn" title="Restablecer Zoom"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg></button>
      <button class="control-button" id="zoom-in-btn" title="Acercar">+</button>
      <button class="control-button" id="zoom-out-btn" title="Alejar">-</button>
      <button class="control-button" id="hand-btn" title="Mover">‚úã</button>
    </div>
           <div id="center-controls">
         <div id="progress-container" title="Verde: P√°ginas vistas | Azul: Progreso total | Gris: Precarga">
           <div id="buffer-bar"></div>
           <div id="pages-progress-bar"></div>
           <div id="progress-bar"></div>
         </div>
       </div>
    <div id="right-controls">
      <button class="control-button" id="fullscreen-btn" title="Pantalla Completa">
        <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
        <svg id="fullscreen-exit-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
      </button>
             <div id="trophy-icon">üèÜ</div>
       <div id="timer"><span class="icon">‚è∞</span><span id="timer-text">00:00</span></div>
    </div>
  </div>
  <div id="error-message"></div>
  <div id="loading-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; display: block; transition: all 0.6s ease-in-out;">
    <div class="loading-container">
      <div class="loading-animation">
        <div class="loading-circle"></div>
        <div class="loading-circle"></div>
        <div class="loading-circle"></div>
      </div>
      <div class="loading-text">
        <div class="loading-title">üéØ</div>
        <div class="loading-subtitle">Cargando Presentaci√≥n</div>
        <div class="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
  </div>
  <audio id="victory-sound" src="audio_c8f5ec4c7e.mp3" preload="auto"></audio>

  <script>
    const params = new URLSearchParams(window.location.search);
    const pdfUrl = params.get("pdf");

    if (!pdfUrl) {
      document.getElementById("error-message").textContent = "Error: No se encontr√≥ la direcci√≥n del PDF en la URL.";
    } else {
      // --- ESTADO Y CONFIGURACI√ìN ---
      let pdfDoc = null, pageNum = 1, scale = 1.0, isHandMode = false, isDragging = false;
      let lastMouseX = 0, lastMouseY = 0, transformX = 0, transformY = 0;
      let isRendering = false, renderQueue = null;
      let pageCache = {};
      const PRELOAD_AHEAD = 4, CACHE_CLEANUP_DISTANCE = 8, MAX_CACHE_SIZE = 12;

             // --- ELEMENTOS DEL DOM ---
       const canvasContainer = document.getElementById("canvas-container");
       const canvas = document.getElementById("pdf-canvas"), ctx = canvas.getContext("2d");
       const loader = document.getElementById("loader");
       const prevButton = document.getElementById("prev-button"), nextButton = document.getElementById("next-button");
       const progressBar = document.getElementById("progress-bar"), bufferBar = document.getElementById("buffer-bar");
       const timerText = document.getElementById("timer-text"), trophyIcon = document.getElementById("trophy-icon");
       const resetZoomBtn = document.getElementById("reset-zoom-btn"), zoomInBtn = document.getElementById("zoom-in-btn");
       const zoomOutBtn = document.getElementById("zoom-out-btn"), handBtn = document.getElementById("hand-btn");
       const fullscreenBtn = document.getElementById("fullscreen-btn");
       const glassOverlay = document.getElementById("glass-overlay");
       let startTime = Date.now();
      
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

             // --- INICIO ---
       pdfjsLib.getDocument(pdfUrl).promise.then(pdf => {
         pdfDoc = pdf;
         
         // Cargar la primera p√°gina inmediatamente sin esperar
         const firstPagePromise = pdf.getPage(1);
         
         // La transici√≥n del indicador de carga se maneja en renderPageImmediately
         // para que desaparezca tan pronto como se muestre la primera p√°gina
         
         // Renderizar la primera p√°gina inmediatamente
         firstPagePromise.then(page => {
           renderPageImmediately(page, 1);
         });
         
         // Iniciar precarga en segundo plano despu√©s de mostrar la primera p√°gina
         setTimeout(() => {
           startPreloading();
         }, 100);
         
         setInterval(() => { const elapsed = Math.floor((Date.now() - startTime) / 1000); timerText.textContent = `${String(Math.floor(elapsed / 60)).padStart(2, '0')}:${String(elapsed % 60).padStart(2, '0')}`; }, 1000);
       }).catch(error => { 
         const loadingMessage = document.getElementById('loading-message');
         loadingMessage.style.opacity = '0';
         loadingMessage.style.transform = 'translate(-50%, -50%) scale(0.8)';
         loadingMessage.style.transition = 'all 0.4s ease-in-out';
         
         setTimeout(() => {
           loadingMessage.style.display = 'none';
           document.getElementById("error-message").textContent = "Error al cargar el PDF: " + error.message; 
           document.getElementById("error-message").style.display = 'block';
         }, 400);
       });

      // --- FUNCI√ìN DE RENDERIZADO INMEDIATO PARA PRIMERA P√ÅGINA (BAJA RESOLUCI√ìN) ---
      async function renderPageImmediately(page, num) {
        pageNum = num;
        
        // PRIMERA FASE: Renderizar en baja resoluci√≥n para carga ultra-r√°pida
        const lowResViewport = page.getViewport({ scale: 0.5 });
        
        // Asegurar que las dimensiones sean v√°lidas
        const validWidth = Math.max(lowResViewport.width, 100);
        const validHeight = Math.max(lowResViewport.height, 100);
        
        canvasContainer.style.width = `${validWidth}px`;
        canvasContainer.style.height = `${validHeight}px`;
        canvas.width = validWidth;
        canvas.height = validHeight;

        // Renderizar en baja resoluci√≥n para mostrar la p√°gina inmediatamente
        await page.render({ canvasContext: ctx, viewport: lowResViewport }).promise;
        
        // Verificar que el canvas se haya renderizado correctamente
        if (canvas.width > 0 && canvas.height > 0) {
          // Ocultar inmediatamente el indicador de carga y mostrar la primera p√°gina
          const loadingMessage = document.getElementById('loading-message');
          loadingMessage.style.opacity = '0';
          loadingMessage.style.transform = 'translate(-50%, -50%) scale(0.8)';
          
          setTimeout(() => {
            loadingMessage.style.display = 'none';
            canvasContainer.style.display = 'block';
            canvasContainer.style.opacity = '0';
            canvasContainer.style.transform = 'scale(0.9)';
            canvasContainer.style.transition = 'all 0.5s ease-out';
            
            setTimeout(() => {
              canvasContainer.style.opacity = '1';
              canvasContainer.style.transform = 'scale(1)';
            }, 50);
          }, 100);
          
          // No mostrar loader para la primera p√°gina
          glassOverlay.classList.remove('active');
          
          // SEGUNDA FASE: Actualizar a alta resoluci√≥n en segundo plano
          setTimeout(() => {
            updateFirstPageToHighResolution(page);
          }, 200);
        } else {
          console.error('Error: Canvas no se renderiz√≥ correctamente');
        }
        
        updateUI();
      }

      // --- FUNCI√ìN PARA ACTUALIZAR PRIMERA P√ÅGINA A ALTA RESOLUCI√ìN ---
      async function updateFirstPageToHighResolution(page) {
        try {
          // Renderizar en alta resoluci√≥n (escala normal)
          const highResViewport = page.getViewport({ scale: 1.0 });
          
          // Asegurar que las dimensiones sean v√°lidas
          const validWidth = Math.max(highResViewport.width, 100);
          const validHeight = Math.max(highResViewport.height, 100);
          
          canvasContainer.style.width = `${validWidth}px`;
          canvasContainer.style.height = `${validHeight}px`;
          canvas.width = validWidth;
          canvas.height = validHeight;

          // Renderizar en alta resoluci√≥n
          await page.render({ canvasContext: ctx, viewport: highResViewport }).promise;
          
          // Actualizar la escala global para mantener consistencia
          scale = 1.0;
          
          console.debug('Primera p√°gina actualizada a alta resoluci√≥n');
        } catch (error) {
          console.error('Error al actualizar primera p√°gina a alta resoluci√≥n:', error);
        }
      }

      // --- L√ìGICA DE RENDERIZADO Y NAVEGACI√ìN OPTIMIZADA ---
      async function handlePageTransition(num) {
        if (num < 1 || num > pdfDoc.numPages) return;
        
        if (isRendering) {
          renderQueue = num;
          return;
        }
        
        isRendering = true;
        pageNum = num;

        // Solo mostrar efecto de cristal sutil, sin loader
        glassOverlay.classList.add('active');
        
        // Verificar si la p√°gina est√° en cach√© y en alta resoluci√≥n
        if (pageCache[num] && !pageCache[num].isLowRes) {
          // Usar p√°gina en cach√© de alta resoluci√≥n
          await renderCachedPage(num);
        } else {
          // Renderizar p√°gina normalmente
          const page = await pdfDoc.getPage(num);
          const viewport = page.getViewport({ scale: scale });

          // Asegurar que las dimensiones sean v√°lidas
          const validWidth = Math.max(viewport.width, 100);
          const validHeight = Math.max(viewport.height, 100);
          
          canvasContainer.style.width = `${validWidth}px`;
          canvasContainer.style.height = `${validHeight}px`;
          canvas.width = validWidth;
          canvas.height = validHeight;

          await page.render({ canvasContext: ctx, viewport: viewport }).promise;
        }
        
        // Verificar que el canvas se haya renderizado correctamente
        if (canvas.width > 0 && canvas.height > 0) {
          // Remover efecto de cristal inmediatamente
          glassOverlay.classList.remove('active');
        } else {
          console.error('Error: Canvas no se renderiz√≥ correctamente');
        }
        
        isRendering = false;
        
        if (renderQueue) {
          const nextNum = renderQueue;
          renderQueue = null;
          handlePageTransition(nextNum);
        }

        updateUI();
        
        // Solo precargar si no es la primera p√°gina (la primera ya se precarg√≥ por separado)
        if (num > 1) {
          startPreloading();
        }
        
        cleanUpCache();
      }

      // --- FUNCI√ìN PARA RENDERIZAR P√ÅGINA EN CACH√â ---
      async function renderCachedPage(pageNum) {
        const cachedPage = pageCache[pageNum];
        if (!cachedPage) return;
        
        // Asegurar que las dimensiones sean v√°lidas
        const validWidth = Math.max(cachedPage.width, 100);
        const validHeight = Math.max(cachedPage.height, 100);
        
        canvasContainer.style.width = `${validWidth}px`;
        canvasContainer.style.height = `${validHeight}px`;
        canvas.width = validWidth;
        canvas.height = validHeight;

        // Dibujar la imagen en cach√©
        ctx.putImageData(cachedPage.imageData, 0, 0);
        
        console.debug(`P√°gina ${pageNum} renderizada desde cach√© (${cachedPage.isLowRes ? 'baja' : 'alta'} resoluci√≥n)`);
      }

      function cleanUpCache() {
        for (const cachedPageNum in pageCache) {
          if (Math.abs(cachedPageNum - pageNum) > CACHE_CLEANUP_DISTANCE) {
            delete pageCache[cachedPageNum];
          }
        }
      }

      // --- FUNCI√ìN DE PRECARGA SILENCIOSA EN SEGUNDO PLANO (BAJA RESOLUCI√ìN INICIAL) ---
      async function startPreloading() {
        // Precarga completamente silenciosa en segundo plano
        const preloadPages = [pageNum + 1, pageNum + 2, pageNum + 3, pageNum + 4];
        
        // Usar Promise.allSettled para precargar todas las p√°ginas en paralelo
        const preloadPromises = preloadPages.map(async (pageToPreload) => {
          if (pageToPreload > pdfDoc.numPages || pageCache[pageToPreload]) return;
          if (Object.keys(pageCache).length >= MAX_CACHE_SIZE) return;

          try {
            const page = await pdfDoc.getPage(pageToPreload);
            
            // PRIMERA FASE: Precargar en baja resoluci√≥n para velocidad
            const lowResViewport = page.getViewport({ scale: 0.5 });
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = lowResViewport.width; 
            tempCanvas.height = lowResViewport.height;
            
            // Renderizar en baja resoluci√≥n para precarga r√°pida
            await page.render({ canvasContext: tempCtx, viewport: lowResViewport }).promise;
            
            // Guardar versi√≥n de baja resoluci√≥n
            pageCache[pageToPreload] = {
              imageData: tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height),
              width: tempCanvas.width, 
              height: tempCanvas.height,
              isLowRes: true, // Marcar como baja resoluci√≥n
              page: page // Guardar referencia a la p√°gina para actualizaci√≥n posterior
            };
            
            // SEGUNDA FASE: Actualizar a alta resoluci√≥n en segundo plano
            setTimeout(async () => {
              try {
                const highResViewport = page.getViewport({ scale: 1.0 });
                const highResCanvas = document.createElement('canvas');
                const highResCtx = highResCanvas.getContext('2d');
                highResCanvas.width = highResViewport.width; 
                highResCanvas.height = highResViewport.height;
                
                await page.render({ canvasContext: highResCtx, viewport: highResViewport }).promise;
                
                // Actualizar cach√© con versi√≥n de alta resoluci√≥n
                pageCache[pageToPreload] = {
                  imageData: highResCtx.getImageData(0, 0, highResCanvas.width, highResCanvas.height),
                  width: highResCanvas.width, 
                  height: highResCanvas.height,
                  isLowRes: false, // Marcar como alta resoluci√≥n
                  page: page
                };
                
                console.debug(`P√°gina ${pageToPreload} actualizada a alta resoluci√≥n`);
              } catch (error) {
                console.debug(`Error al actualizar p√°gina ${pageToPreload} a alta resoluci√≥n:`, error);
              }
            }, 500 + (pageToPreload - pageNum) * 100); // Escalonar las actualizaciones
            
            // Actualizar UI de manera silenciosa
            requestAnimationFrame(() => {
              updateUI();
            });
            
          } catch (error) { 
            // Silenciar errores de precarga para no molestar al usuario
            console.debug(`Precarga silenciosa fallida para p√°gina ${pageToPreload}:`, error); 
          }
        });
        
        // Ejecutar todas las precargas en paralelo sin bloquear
        Promise.allSettled(preloadPromises).then(() => {
          // Precarga completada silenciosamente
          console.debug('Precarga en segundo plano completada');
        });
      }

      // --- FUNCI√ìN DE REDIBUJADO OPTIMIZADA ---
      async function redrawCurrentPage() {
        if (isRendering) return;
        isRendering = true;
        
        // Solo mostrar efecto de cristal muy sutil para zoom/paneo
        glassOverlay.classList.add('active');
        
        // Forzar re-renderizado sin usar cach√© para asegurar la nueva escala/paneo
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: scale });

        // Asegurar que las dimensiones sean v√°lidas
        const validWidth = Math.max(viewport.width, 100);
        const validHeight = Math.max(viewport.height, 100);
        
        canvasContainer.style.width = `${validWidth}px`;
        canvasContainer.style.height = `${validHeight}px`;
        canvas.width = validWidth;
        canvas.height = validHeight;

        await page.render({ canvasContext: ctx, viewport: viewport }).promise;

        // Verificar que el canvas se haya renderizado correctamente
        if (canvas.width > 0 && canvas.height > 0) {
          glassOverlay.classList.remove('active');
        } else {
          console.error('Error: Canvas no se redibuj√≥ correctamente');
        }
        
        isRendering = false;
        updateUI(); // Actualizar UI despu√©s del redibujado
      }

      // --- INTERACCIONES DE USUARIO ---
      function zoomIn() { scale = Math.min(scale + 0.2, 3.0); redrawCurrentPage(); } // Llama a redrawCurrentPage
      function zoomOut() { scale = Math.max(scale - 0.2, 0.5); redrawCurrentPage(); } // Llama a redrawCurrentPage
      function resetZoom() { scale = 1.0; transformX = 0; transformY = 0; canvasContainer.style.transform = `translate(0px, 0px)`; redrawCurrentPage(); } // Llama a redrawCurrentPage
      
      function prevPage() { handlePageTransition(pageNum - 1); }
      function nextPage() { handlePageTransition(pageNum + 1); }

      function toggleHand() { isHandMode = !isHandMode; canvasContainer.style.cursor = isHandMode ? 'grab' : 'default'; handBtn.classList.toggle('active', isHandMode); } 
      const handleMouseDown = (e) => { if (isHandMode) { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; canvasContainer.style.cursor = 'grabbing'; } };
      const handleMouseMove = (e) => { if (isDragging) { const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY; transformX += dx; transformY += dy; canvasContainer.style.transform = `translate(${transformX}px, ${transformY}px)`; lastMouseX = e.clientX; lastMouseY = e.clientY; } };
      const stopDragging = () => { isDragging = false; if (isHandMode) canvasContainer.style.cursor = 'grab'; };
      
      // --- PANTALLA COMPLETA Y UI ---
      function toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); } else { document.exitFullscreen(); } }
      function updateFullscreenIcons() { const isFullscreen = !!document.fullscreenElement; document.getElementById('fullscreen-enter-icon').style.display = isFullscreen ? 'none' : 'block'; document.getElementById('fullscreen-exit-icon').style.display = isFullscreen ? 'block' : 'none'; }
             function updateUI() {
           if (!pdfDoc) return;
           prevButton.disabled = (pageNum <= 1);
           nextButton.disabled = (pageNum >= pdfDoc.numPages);
           
                       // Indicador de progreso de lectura (p√°ginas vistas)
            const readProgress = (pageNum / pdfDoc.numPages) * 100;
            progressBar.style.width = `${readProgress}%`;

            // Indicador de progreso de p√°ginas vistas (azul transparente)
            const pagesProgress = (pageNum / pdfDoc.numPages) * 100;
            document.getElementById('pages-progress-bar').style.width = `${pagesProgress}%`;

            // Indicador de progreso de precarga (buffer)
            let preloadedCount = 0;
            const totalPagesToPreloadConsidered = Math.min(pdfDoc.numPages - pageNum, PRELOAD_AHEAD);
            
            for (let i = 1; i <= totalPagesToPreloadConsidered; i++) {
                if (pageCache[pageNum + i]) {
                    preloadedCount++;
                }
            }

            let bufferProgress = 0;
            if (totalPagesToPreloadConsidered > 0) {
                bufferProgress = (preloadedCount / totalPagesToPreloadConsidered) * 100;
            } else if (pageNum === pdfDoc.numPages) {
                bufferProgress = 100;
            }

            const combinedProgress = readProgress + (bufferProgress * (100 - readProgress) / 100);
            bufferBar.style.width = `${combinedProgress}%`;

           // Mostrar el trofeo cuando se llegue a la √∫ltima p√°gina
           if (pageNum === pdfDoc.numPages) {
             trophyIcon.style.display = 'flex';
             // Solo activar la explosi√≥n una vez por sesi√≥n
             if (!trophyIcon.dataset.exploded) {
                 console.log('üèÜ Activando trofeo en p√°gina final');
                 setTimeout(() => {
                     console.log('üéä Ejecutando explosi√≥n de trofeos');
                     triggerTrophyExplosion();
                     trophyIcon.dataset.exploded = 'true';
                 }, 500); // Peque√±o delay para asegurar que la p√°gina est√© completamente cargada
             }
           } else {
             trophyIcon.style.display = 'none';
           }
       }
      
      // --- ANIMACI√ìN DE TROFEOS --- 
      function createBurst(numTrophies = 15, spreadRadius = 150) {
        for (let i = 0; i < numTrophies; i++) {
          const trophy = document.createElement('div');
          trophy.textContent = 'üèÜ';
          trophy.classList.add('explosion-trophy');
          const angle = Math.random() * 2 * Math.PI;
          const dx = Math.cos(angle) * (Math.random() * spreadRadius + 50);
          const dy = Math.sin(angle) * (Math.random() * spreadRadius + 50);
          trophy.style.setProperty('--dx', `${dx}px`);
          trophy.style.setProperty('--dy', `${dy}px`);
          trophy.style.animationDelay = `${Math.random() * 0.5}s`;
          document.getElementById('trophy-explosion-container').appendChild(trophy);
        }
      }

             async function triggerTrophyExplosion() {
         // Reproducir sonido de victoria
         const victorySound = document.getElementById('victory-sound');
         if (victorySound) {
           try {
             victorySound.currentTime = 0;
             await victorySound.play();
           } catch (error) {
             console.error("Error al reproducir el sonido:", error);
           }
         }
         
         // Crear explosi√≥n de trofeos
         const trophyExplosionContainer = document.getElementById('trophy-explosion-container');
         if (trophyExplosionContainer) {
           trophyExplosionContainer.innerHTML = ''; 
           const numBursts = 4, delayBetweenBursts = 300;
           
           for (let i = 0; i < numBursts; i++) {
             createBurst(15, 200);
             await new Promise(resolve => setTimeout(resolve, delayBetweenBursts));
           }
           
           const totalAnimationTime = (numBursts * delayBetweenBursts) + 4000;
           setTimeout(() => { 
             trophyExplosionContainer.innerHTML = ''; 
           }, totalAnimationTime);
         }
       }

      // --- EVENT LISTENERS ---
      prevButton.addEventListener("click", prevPage);
      nextButton.addEventListener("click", nextPage);
      zoomInBtn.addEventListener("click", zoomIn);
      zoomOutBtn.addEventListener("click", zoomOut);
      resetZoomBtn.addEventListener("click", resetZoom);
      handBtn.addEventListener("click", toggleHand);
             fullscreenBtn.addEventListener("click", toggleFullscreen);
       document.addEventListener('fullscreenchange', updateFullscreenIcons);
      canvasContainer.addEventListener('mousedown', handleMouseDown);
      canvasContainer.addEventListener('mousemove', handleMouseMove);
      canvasContainer.addEventListener('mouseup', stopDragging);
      canvasContainer.addEventListener('mouseleave', stopDragging);
    }
  </script>
</body>
</html>


